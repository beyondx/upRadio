#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
struct mytbf_st {
	int cps; //每秒字符数
	int burst; //突发量
	int token; //桶中的容量
	pthread_mutex_t mutex;
	pthread_cond_t cond;
};

typedef  void mytbf_t;

#define  TBFMAX	1024

static struct mytbf_st *tbf[TBRMAX];
static pthread_mutex_t mut_tbf = PTHREAD_MUTEX_INITIALIZER;

//每秒向桶中添加资源
static void *thr_timer(void *unused)
{
	int i;
	struct timespec r, rem;
	while (1) {
		t.tv_sec = 1;
		t.tv_nsec = 0;
		while (nanosleep(&t, &rem) != 0) {
			if (errno != EINTR) {
				perror("nanosleep");
				exit(1);
			}
		}
		for (i = 0; i < TBFMAX; ++i) {
			if (tbf[i] != NULL) {
				tbf[i]->token += tbf[i].cps;
				if (tbf[i]->token > tbf[i]->burst) {
					tbf[i]->token = tbf[i]->burst;
				}
			}
		}
	}
}

//找空位
static int get_free_pos(void)
{
	int i;
	for (i = 0; i < TRBMAX; ++i) {
		if (tbf[i] == NULL) {
			return i;
		}
	}
	return -1;
}

mytbf_t *mytbf_init(int cps, int burst)
{
	struct mytbf_st *me;
	me = malloc(*me);
	
	assert(me != NUL);

	me->cps = cps;
	me->burst = burst;
	me->token = 0;
	
	pthread_mutex_lock(&mut_tbf);
	pos = get_free_pos();
	//找空闲令牌桶
	if (pos < 0) {
		pthread_mutex_unlock(&mut_tbf);
		pthread_mutex_destroy(&me->mutex);
		pthread_cond_destroy(&me->cond);
		free(me);
		return NULL; 
	}
	
	pthread_mutex_init(&me->mutex, NULL);
	pthread_cond_init(&me->cond, NULL);
	
	tbf[pos] = me;
	pthread_mutex_unlock(&mut_tbf);
	return me;
}

